#include "hspogg.as"
#include "mod_joystick.as"

#define TRUE 1
#define FALSE 0

// screen size
#define SCREEN_X 640
#define SCREEN_Y 480
// a stage chip amount(x * y)
#define STAGE_X 256
#define STAGE_Y 256
//a chip width and height
#define CHIPSIZE 32
//player width and height
#define PLAYER_WIDTH 30
#define PLAYER_HEIGHT 60
//enemy number on map file
#define ENEMY_CHIP_START_NUMBER 50
//enemy max count
#define ENEMY_COUNT_MAX 16
//enemy action count max
#define ENEMYACTION_COUNT_MAX 3
#define ENEMYCOND_COUNT_MAX 8
#define ENEMYACTIONSAMETIME_COUNT_MAX 5
//enemy direction value
#define ENEMY_LEFT  -1
#define ENEMY_RIGHT 1

//enemy move id
#define ENEMY_DONT_MOVE    -1
#define ENEMY_MOVE_PROCEED 1

//enemy action id
#define ENEMY_ACTION_JUMP         1
#define ENEMY_ACTION_RETURN       2
#define ENEMY_ACTION_TURNTOPLAYER 3
#define ENEMY_ACTION_SETSTATE     4
#define ENEMY_ACTION_ADDSTATE     5

//enemy condition id
#define ENEMY_COND_DEFAULT    1
#define ENEMY_COND_FRONTWALL  2
#define ENEMY_COND_MATCHSTATE 3

dim chip, STAGE_X, STAGE_Y

//enemy attribute valiables
dim enemyIsUsed,ENEMY_COUNT_MAX
ddim enemyX, ENEMY_COUNT_MAX
ddim enemyY, ENEMY_COUNT_MAX
ddim enemyOriginX, ENEMY_COUNT_MAX
ddim enemyOriginY, ENEMY_COUNT_MAX
ddim enemyXV, ENEMY_COUNT_MAX
ddim enemyYV, ENEMY_COUNT_MAX
dim enemyWidth, ENEMY_COUNT_MAX
dim enemyHeight, ENEMY_COUNT_MAX
dim enemyID, ENEMY_COUNT_MAX
dim enemyImageHandle, ENEMY_COUNT_MAX
dim enemyIsAlive, ENEMY_COUNT_MAX
dim enemyHP, ENEMY_COUNT_MAX
dim enemyState, ENEMY_COUNT_MAX
dim enemyDirection, ENEMY_COUNT_MAX
ddim enemyMoveValue, ENEMY_COUNT_MAX, ENEMYACTION_COUNT_MAX, ENEMYACTIONSAMETIME_COUNT_MAX
dim enemyMoveType, ENEMY_COUNT_MAX, ENEMYACTION_COUNT_MAX, ENEMYACTIONSAMETIME_COUNT_MAX
dim enemyMoveTypeCondition, ENEMY_COUNT_MAX, ENEMYACTION_COUNT_MAX, ENEMYCOND_COUNT_MAX
ddim enemyMoveTypeConditionValue, ENEMY_COUNT_MAX, ENEMYACTION_COUNT_MAX, ENEMYCOND_COUNT_MAX
dim enemyActionType, ENEMY_COUNT_MAX, ENEMYACTION_COUNT_MAX, ENEMYACTIONSAMETIME_COUNT_MAX
dim enemyActionCondition, ENEMY_COUNT_MAX, ENEMYACTION_COUNT_MAX, ENEMYCOND_COUNT_MAX
ddim enemyActionValue, ENEMY_COUNT_MAX, ENEMYACTION_COUNT_MAX, ENEMYACTIONSAMETIME_COUNT_MAX
ddim enemyActionConditionValue, ENEMY_COUNT_MAX, ENEMYACTION_COUNT_MAX, ENEMYCOND_COUNT_MAX

enemyCount = 0

dmmini

goto *init 

//Hit decision instruction
#deffunc collide  var objectX, var objectY, var objectXV, var objectYV, var jump, int objectWidth, int objectHeight, str objectType
	jump = 0
	repeat objectHeight / CHIPSIZE + 5
		ccnt = cnt
		repeat objectWidth / CHIPSIZE + 5

			//decide block index
			x = int(objectX) / CHIPSIZE + cnt - 2
			y = int(objectY) / CHIPSIZE + ccnt - 2
			if(x < 0 || x >= STAGE_X) : continue
			if(y < 0 || y >= STAGE_Y) : continue

			//ignore through chip
			if(chip(x, y) == 0) : continue

			if(chipType(chip(x, y) - 1) == 0){ //chips that cannot pass through
				//ride on the block
				if(objectType == "player"){
					allowStep = isDash * 3
				}else{
					allowStep = 0
				}
				if((objectY + objectHeight / 2 <= y * CHIPSIZE + allowStep)){// before add speed
					objectLeftlegIsInTheBlock = inRect(objectX + objectXV - objectWidth / 2, objectY + objectYV + objectHeight / 2, x * CHIPSIZE, y * CHIPSIZE, (x + 1) * CHIPSIZE, (y + 1) * CHIPSIZE, FALSE, TRUE)
					objectRightlegIsInTheBlock = inRect(objectX + objectXV + objectWidth / 2, objectY + objectYV + objectHeight / 2, x * CHIPSIZE, y * CHIPSIZE, (x + 1) * CHIPSIZE, (y + 1) * CHIPSIZE, FALSE, TRUE)
					if(objectLeftlegIsInTheBlock || objectRightlegIsInTheBlock){//after add speed
						jump = 1
						objectY = double(y * CHIPSIZE) - double(objectHeight / 2)
						objectYV = 0.0
					}
				}else : if((objectY + objectHeight / 2 > y * CHIPSIZE)){// before add speed
					if(abs(objectX + objectXV - (x * CHIPSIZE + CHIPSIZE / 2)) < objectWidth / 2 + CHIPSIZE / 2 && abs(objectY + objectYV - (y * CHIPSIZE + CHIPSIZE / 2)) < objectHeight / 2 + CHIPSIZE / 2){ //after add speed
						hasUnderBlock = 0
						if(y + 1 < STAGE_Y){
							if(chip(x, y + 1) - 1 >= 0){
								if(chipType(chip(x, y + 1) - 1) == 0){ //there is a block under this block
									hasUnderBlock = 1
								}
							}
						}
						if(objectY - objectHeight / 2 <= (y + 1) * CHIPSIZE || hasUnderBlock){//from side
							if(objectX < x * CHIPSIZE + CHIPSIZE / 2){
								objectX = double(x * CHIPSIZE - objectWidth / 2)
							}else{
								objectX = double((x + 1) * CHIPSIZE + objectWidth / 2)
							}
							objectXV = 0.0
						}else{//from under
							objectY = double((y + 1) * CHIPSIZE + objectHeight / 2)
							objectYV = 1.0
						}
					}
				}
			}
		loop
	loop
	return

#defcfunc judgeCondition int chara_index, array typeCondition, array typeConditionValue
	cond_num = 0
	default_index = -1
	repeat ENEMYACTION_COUNT_MAX
		ccnt__ = cnt
		if(typeCondition(chara_index, cnt, 0) != 0){
			match = TRUE
		}else{
			match = FALSE
		}
		repeat ENEMYCOND_COUNT_MAX
			mes "cnt:" + cnt
			mes "type_cond:" + typeCondition(chara_index, ccnt__, cnt)
			mes "default:" + default_index
			if(typeCondition(chara_index, ccnt__, cnt) == ENEMY_COND_DEFAULT){
				match = FALSE
				default_index = ccnt__
				break
			}else : if(typeCondition(chara_index, ccnt__, cnt) == ENEMY_COND_FRONTWALL){
				x = int(enemyX(chara_index) + (enemyWidth(chara_index) / 2 + typeConditionValue(chara_index, ccnt__, cnt) + 1.0) * enemyDirection(chara_index)) / CHIPSIZE
				y = int(enemyY(chara_index)) / CHIPSIZE
				if(x >= 0 && x < STAGE_X && y >= 0 && y < STAGE_Y){
					// boxf x * CHIPSIZE - cameraX, y * CHIPSIZE - cameraY, (x + 1) * CHIPSIZE - cameraX, (y + 1) * CHIPSIZE - cameraY 
					if(chip(x, y) > 0){
						if(chipType(chip(x, y) - 1) == 0){
							mes "frontwall"
							continue
						}
					}
				}
			}else : if(typeCondition(chara_index, ccnt__, cnt) == ENEMY_COND_MATCHSTATE){
				if(enemyState(chara_index) == int(typeConditionValue(chara_index, ccnt__, cnt))){
					continue
				}
			}else : if(typeCondition(chara_index, ccnt__, cnt) == 0){
				break
			}
			match = FALSE
			break
		loop
		if(match){
			mes "match"
			cond_num = cnt
			break
		}
		if(cnt == ENEMYACTION_COUNT_MAX - 1){
			cond_num = default_index
			break
		}
	loop
	return cond_num

#deffunc setEnemyAttrValue int chara_index_, int condition_index_, array moveType, array moveTypeCondition, array moveValue, array moveTypeConditionValue, str attr, local namevalue, local name, local value, local condition
	// name(value) in condition
	attr_valiable = attr
	namevalue = ""
	name = ""
	value = ""
	condition = ""
	split attr_valiable, "in", namevalues, condition
	split namevalues, ",", namevalue
	repeat stat
		split namevalue(cnt), "(", name, value
		value = strtrim(value)
		value = strtrim(value, 0, ')')
		name = strtrim(name)
		condition = strtrim(condition)
		mes "name : " + name
		mes "value : " + value
		mes "cond : \"" + condition + "\""
		switch name
			//move
			case "stop" : moveType(chara_index_, condition_index_, cnt) = ENEMY_DONT_MOVE : swbreak
			case "proceed" : moveType(chara_index_, condition_index_, cnt) = ENEMY_MOVE_PROCEED : swbreak
			//action
			case "jump" : moveType(chara_index_, condition_index_, cnt) = ENEMY_ACTION_JUMP : swbreak
			case "return" : moveType(chara_index_, condition_index_, cnt) = ENEMY_ACTION_RETURN : swbreak
			case "turn_to_player" : moveType(chara_index_, condition_index_, cnt) = ENEMY_ACTION_TURNTOPLAYER : swbreak
			case "setstate" : moveType(chara_index_, condition_index_, cnt) = ENEMY_ACTION_SETSTATE : swbreak
			case "addstate" : moveType(chara_index_, condition_index_, cnt) = ENEMY_ACTION_ADDSTATE : swbreak
			default : moveType(chara_index_, condition_index_, cnt) = ENEMY_DONT_MOVE : swbreak
		swend
		if(moveType(chara_index_, condition_index_, cnt) != ENEMY_DONT_MOVE){
			moveValue(chara_index_, condition_index_, cnt) = double(value)
		}
	loop
	split condition, "and", tmp_cond
	repeat stat
		setEnemyConditionAttrValue moveTypeCondition(chara_index_, condition_index_, cnt), moveTypeConditionValue(chara_index_, condition_index_, cnt), strtrim(tmp_cond(cnt))
	loop
	return

#deffunc setEnemyConditionAttrValue var moveCond, var moveCondValue, str avalue, local namevalue, local name, local value
	mes avalue
	namevalue = avalue
	name = ""
	value = ""
	split namevalue, "(", name, value
	value = strtrim(value)
	value = strtrim(value, 0, ')')
	name = strtrim(name)
	mes "name2 : " + name
	mes "value2 : " + value
	switch name
		case "default" : moveCond = ENEMY_COND_DEFAULT : swbreak
		case "frontwall" : moveCond = ENEMY_COND_FRONTWALL : swbreak
		case "stateis" : moveCond = ENEMY_COND_MATCHSTATE : swbreak
		default : moveCond = 0 : swbreak
	swend
	mes "moveCond = " + moveCond
	mes ENEMY_COND_DEFAULT
	moveCondValue = double(value)
	return

#deffunc enemySpawn int pointX, int pointY, int ID
	repeat ENEMY_COUNT_MAX
		if(enemyIsUsed(cnt) == FALSE){
			enemyIsUsed(cnt) = TRUE
			enemyX(cnt) = double(pointX)
			enemyY(cnt) = double(pointY)
			enemyOriginX(cnt) = double(pointX)
			enemyOriginY(cnt) = double(pointY)
			if(inRect(enemyX(cnt), enemyY(cnt), cameraX - 100, cameraY - 100, cameraX + SCREEN_X + 100, cameraY + SCREEN_Y + 100, FALSE, FALSE)){
				enemyIsAlive(cnt) = TRUE
			}else{
				enemyIsAlive(cnt) = FALSE
			}
			enemyID(cnt) = ID
			enemyXV(cnt) = 0.0
			enemyYV(cnt) = 0.0
			enemyWidth(cnt) = int(getAttributeString(enemyNote, ID, "width", 0))
			enemyHeight(cnt) = int(getAttributeString(enemyNote, ID, "height", 0))
			enemyHP(cnt) = int(getAttributeString(enemyNote, ID, "hp", 0))
			ccnt_ = cnt
			mes "loop start"
			repeat
				attrvalue = getAttributeString(enemyNote, ID, "move", cnt)
				mes "attrvalue = " + attrvalue
				if(attrvalue == "null") : break
				setEnemyAttrValue ccnt_, cnt, enemyMoveType, enemyMoveTypeCondition, enemyMoveValue, enemyMoveTypeConditionValue, attrvalue
				// mes "result : " + str(enemyMoveType(ccnt_, cnt)) + " " + str(enemyMoveTypeCondition(ccnt_, cccnt, cnt)) + " " + str(enemyMoveValue(ccnt_, cccnt, cnt)) + " " + str(enemyMoveTypeConditionValue(ccnt_, cccnt, cnt))
				// await 1
			loop
			repeat
				attrvalue = getAttributeString(enemyNote, ID, "action", cnt)
				mes "attrvalue = " + attrvalue
				if(attrvalue == "null") : break
				setEnemyAttrValue ccnt_, cnt, enemyActionType, enemyActionCondition, enemyActionValue, enemyActionConditionValue, attrvalue
				// mes "result : " + str(enemyActionType(ccnt_, cccnt, cnt)) + " " + str(enemyActionCondition(ccnt_, cccnt, cnt)) + " " + str(enemyActionValue(ccnt_, cccnt, cnt)) + " " + str(enemyActionConditionValue(ccnt_, cccnt, cnt))
			loop
			; // redraw 1
			; // stop
			enemyDirection(cnt) = ENEMY_LEFT
			enemyCount++
			break
		}
	loop
	return 

#deffunc enemyDespawn int cnt_index
	enemyX(cnt_index) = enemyOriginX(cnt_index)
	enemyY(cnt_index) = enemyOriginY(cnt_index)
	enemyState(cnt_index) = 0
	enemyDirection(cnt_index) = ENEMY_LEFT
	enemyIsAlive(cnt_index) = FALSE
	return

#deffunc get_input
	joyGetPosEx joypad
	left = 0
	right = 0
	x = 0
	z = 0
	if(ginfo(2) != -1){
		getkey left, 37
		getkey right, 39
		getkey z, 'Z'
		getkey x, 'X'
	}
	if(stat == 0){
		if(joypad(2) < 32000 - 16000){
			left = 1
		}
		if(joypad(2) > 32000 + 16000){
			right = 1
		}
		if(joypad(8) & 1){
			z = 1
		}
		if(joypad(8) & 4){
			x = 1
		}
	}
	return

#defcfunc inRect double pointX, double pointY, double rectX1, double rectY1, double rectX2, double rectY2, int includeXEdge, int includeYEdge
	if(includeXEdge){
		xCond = pointX >= rectX1 && pointX <= rectX2
	}else{
		xCond = pointX > rectX1 && pointX < rectX2
	}
	if(includeYEdge){
		yCond = pointY >= rectY1 && pointY <= rectY2
	}else{
		yCond = pointY > rectY1 && pointY < rectY2
	}
	if(xCond && yCond){
		return TRUE
	}else{
		return FALSE
	}
	return FALSE

#defcfunc getAttributeString var note, int ID, str attributeName, int num
	notesel note
	now_id = 0
	linebuf = ""
	attrname = ""
	attrvalue = ""
	retval = "null"
	num_valiable = num
	repeat notemax
		noteget linebuf, cnt
		linebuf_trim = strtrim(linebuf)
		if(peek(linebuf_trim, 0) == '#') : continue
		if(strmid(linebuf_trim, 0, 3) == "---"){
			now_id++
			continue
		}
		if(now_id == ID){
			split linebuf, ":", attrname, attrvalue
			if(strtrim(attrname) == attributeName){
				if(num_valiable > 0){
					num_valiable--
				}else{
					retval = strtrim(attrvalue)
					break
				}
			}
		}
	loop
	noteunsel
	return retval

#deffunc camera double centerX, double centerY, int mapX, int mapY
	cameraX = centerX - double(SCREEN_X / 2)
	cameraY = centerY - double(SCREEN_Y / 2)
	if(cameraX < 0): cameraX = 0
	if(cameraX + SCREEN_X > mapX * CHIPSIZE): cameraX = mapX * CHIPSIZE - SCREEN_X
	if(cameraY < 0): cameraY = 0
	if(cameraY + SCREEN_Y > mapY * CHIPSIZE): cameraY = mapY * CHIPSIZE - SCREEN_Y
	return

*init

	game_state = *game_init

	title "ƒ^ƒCƒgƒ‹–¢’è"

	playerX = 100.0
	playerY = 100.0
	playerXV = 0.0
	playerYV = 0.0

	cameraX = 0.0
	cameraY = 0.0

	grabityA = 0.4

	Z_Frame = 0
	Z_Trigger = FALSE

	playerJump = 0

	celload DIR_CUR + "\\data\\chip.png", 1
	celdiv 1, CHIPSIZE, CHIPSIZE, 0, 0
	gsel 1
	chipCount = ginfo(12) / CHIPSIZE
	gsel 0

	dim chipType, chipCount

	celload DIR_CUR + "\\data\\player.png", 3
	celdiv 3, PLAYER_WIDTH, PLAYER_HEIGHT, 0, 0

	notesel notebuf
	noteload DIR_CUR + "\\data\\chiptype.txt"
	index = 0
	repeat chipCount
		getstr chipattr, line_buf, index, ',', 8
		chipType(cnt) = int(chipattr)
		index += strsize
	loop
	
	celload DIR_CUR + "\\data\\dash_page8.png", 4
	celdiv 4, 40, 60, 0, 0

	notesel enemyNote
	noteload DIR_CUR + "\\data\\enemy.txt"

	gmode 2
	
	dim joypad, 13

//main roop
repeat
	redraw 0
	gosub game_state
	redraw 1
	
	await 16
loop

*title_
	//TODO: Œã‚Åì‚é
	return

*game_init

	//load data of map
	notesel notebuf
	mapFileName = "map_no" + mapNumber + ".txt"
	noteload mapFileName
	noteget line_buf, 0
	split line_buf, ",", mapSizeX, mapSizeY
	mapSizeX = int(mapSizeX)
	mapSizeY = int(mapSizeY)
	noteget line_buf, 1
	mapBgmFile = line_buf
	noteget line_buf, 2
	mapBackImageFile = line_buf
	celload DIR_CUR + "\\data\\" + mapBackImageFile, 2
	gsel 2
	backX = ginfo(12)
	backY = ginfo(13)
	gsel 0
	playerX = 100.0
	playerY = 100.0
	playerXV = 0.0
	playerYV = 0.0
	camera playerX, playerY, mapSizeX, mapSizeY
	repeat STAGE_Y
		index = 0
		noteget line_buf, cnt + 3
		ccnt = cnt
		repeat STAGE_X
			getstr chipattr, line_buf, index, ',', 8
			index += strsize
			if(int(chipattr) >= ENEMY_CHIP_START_NUMBER){
				enemySpawn cnt * CHIPSIZE + CHIPSIZE / 2, ccnt * CHIPSIZE + CHIPSIZE / 2, int(chipattr) - ENEMY_CHIP_START_NUMBER
				chip(cnt, ccnt) = 0
			}else{
				chip(cnt, ccnt) = int(chipattr)
			}
		loop
	loop

	//next_state -> "game"
	game_state = *game
	return

	//init enemy variables
	repeat ENEMY_COUNT_MAX
		enemyIsUsed(cnt) = FALSE
	loop

*game

	//set camera position
	camera playerX, playerY, mapSizeX, mapSizeY
	
	//draw back image
	pos -(double(cameraX) / double(mapSizeX * CHIPSIZE - SCREEN_X)) * double(backX - SCREEN_X), -(double(cameraY) / double(mapSizeY * CHIPSIZE - SCREEN_Y)) * double(backY - SCREEN_Y)
	celput 2 

	//draw mapchip
	repeat SCREEN_Y / CHIPSIZE + 1
		ccnt = cnt
		repeat SCREEN_X / CHIPSIZE + 1
			pos -cameraX \ CHIPSIZE + cnt * CHIPSIZE, -cameraY \ CHIPSIZE + ccnt * CHIPSIZE
			if(cameraX / CHIPSIZE + cnt < 0 || cameraX / CHIPSIZE + cnt > mapSizeX * CHIPSIZE) : continue
			if(cameraY / CHIPSIZE + ccnt < 0 || cameraY / CHIPSIZE + ccnt > mapSizeY * CHIPSIZE) : continue
			chipid = chip(int(cameraX / CHIPSIZE + cnt), int(cameraY / CHIPSIZE + ccnt))
			if(chipid == 0):continue //ignore null chip
			if(chipid >= ENEMY_CHIP_START_NUMBER):continue //ignore enemy chip
			celput 1, chipid - 1
		loop
	loop

	//draw player
	; boxf playerX - cameraX - PLAYER_WIDTH / 2, playerY - cameraY - PLAYER_HEIGHT / 2, playerX - cameraX + PLAYER_WIDTH / 2, playerY - cameraY + PLAYER_HEIGHT / 2
	if(absf(playerXV) < 0.1){
		pos playerX - PLAYER_WIDTH / 2 - cameraX, playerY - PLAYER_HEIGHT / 2 - cameraY
		celput 3, playerFrame / 6 \ 6 + playerDirection * 6
	}else{
		if(playerDirection == 0){
			xZoom = 1
		}else{
			xZoom = -1
		}
		pos playerX - 40 / 2 - cameraX + 40 / 2 - xZoom * 20, playerY - 60 / 2 - cameraY
		a = playerFrame / 3 \ 10
		celput 4, ((a)\10-1)+((a)\5-1 < 0)-int((a\10)/5), xZoom
	}
	if(playerXV < 0) : playerDirection = 0
	if(playerXV > 0) : playerDirection = 1
	playerFrame++

	//get button push state
	get_input

	//dash button
	if(x){
		playerV = 4.5
	}else{
		playerV = 2.0
	}

	//input player move
	if left{
		playerDirection = 0
		if(playerXV > 0.0){
			playerXV += (-playerV - playerXV) * 0.1
		}else{
			playerXV = -playerV
		}
	}
	if right{
		playerDirection = 1
		if(playerXV < 0.0){
			playerXV += (playerV - playerXV) * 0.1
		}else{
			playerXV = playerV
		}
	}
	if(left == 0 && right == 0) : playerXV += (0.0 - playerXV) * 0.1

	//jump key
	if(z && playerJump && Z_Frame == 0 && Z_Trigger){
		Z_Frame = 15
		playerJump = 0
	}
	if(z){
		Z_Trigger = FALSE
	}else{
		Z_Trigger = TRUE
	}
	if(z && Z_Frame != 0){
		Z_Frame--
	}
	if(Z_Frame != 0){
		playerYV = -7.0
	}
	if(z == 0 && Z_Frame != 0){
		Z_Frame = 0
		Z_Trigger = TRUE
	}

	//grabity
	playerYV += grabityA

	//collide to block
	playerJump = 0
	isDash = 0
	if(x):isDash = 1
	collide playerX, playerY, playerXV, playerYV, playerJump, PLAYER_WIDTH, PLAYER_HEIGHT, "player"

	//add player speed to position
	playerX += playerXV
	playerY += playerYV

	//enemy draw
	repeat enemyCount
		if(enemyIsAlive(cnt)){
			pos enemyX(cnt) - cameraX, enemyY(cnt) - cameraY
			boxf enemyX(cnt) - enemyWidth(cnt) / 2 - cameraX, enemyY(cnt) - enemyHeight(cnt) / 2 - cameraY, enemyX(cnt) + enemyWidth(cnt) / 2 - cameraX, enemyY(cnt) + enemyHeight(cnt) / 2 - cameraY
		}
	loop

	//enemy spawn
	repeat enemyCount
		if(inRect(enemyX(cnt), enemyY(cnt), cameraX - 200, cameraY - 200, cameraX + SCREEN_X + 200, cameraY + SCREEN_Y + 200, FALSE, FALSE) && inRect(enemyX(cnt), enemyY(cnt), cameraX - 100, cameraY - 100, cameraX + SCREEN_X + 100, cameraY + SCREEN_Y + 100, FALSE, FALSE) == FALSE){
			if(enemyIsAlive(cnt) == FALSE){
				enemyIsAlive(cnt) = TRUE
			}
		}
	loop

	//enemy despawn
	repeat enemyCount
		if(enemyIsAlive(cnt)){
			if(inRect(enemyX(cnt), enemyY(cnt), cameraX - 300, cameraY - 300, cameraX + SCREEN_X + 300, cameraY + SCREEN_Y + 300, FALSE, FALSE) == FALSE){
				enemyDespawn cnt
			}
		}
	loop

	//enemy action
	repeat enemyCount
		if(enemyIsAlive(cnt)){
			pos cnt * 100, 0
			mes "state:" + enemyState(cnt)
			mes "[action]"
			cond_num = judgeCondition(cnt, enemyActionCondition, enemyActionConditionValue)
			mes "result:" + cond_num
			if(cond_num == -1) : continue
			ccnt = cnt
			repeat ENEMYACTIONSAMETIME_COUNT_MAX
				if(enemyActionType(ccnt, cond_num, cnt) == ENEMY_ACTION_JUMP){
					x = int(enemyX(ccnt) / CHIPSIZE)
					y = int((enemyY(ccnt) + enemyHeight(ccnt) / 2 + 1) / CHIPSIZE)
					if(x >= 0 && x < STAGE_X && y >= 0 && y < STAGE_Y){
					// boxf x * CHIPSIZE - cameraX, y * CHIPSIZE - cameraY, (x + 1) * CHIPSIZE - cameraX, (y + 1) * CHIPSIZE - cameraY 
						if(chip(x, y) > 0){
							if(chipType(chip(x, y) - 1) == 0){
								pos enemyX(ccnt) - cameraX, enemyY(ccnt) - cameraY
								mes "JUMP"
								enemyYV(ccnt) = -enemyActionValue(ccnt, cond_num, cnt)
								mes "aaaa"
								mes "val:" + enemyActionValue(ccnt, cond_num, cnt)
							}
						}
					}
				}else : if(enemyActionType(ccnt, cond_num, cnt) == ENEMY_ACTION_RETURN){
					enemyDirection(ccnt) *= -1
				}else : if(enemyActionType(ccnt, cond_num, cnt) == ENEMY_ACTION_SETSTATE){
					enemyState(ccnt) = int(enemyActionValue(ccnt, cond_num, cnt))
				}else : if(enemyActionType(ccnt, cond_num, cnt) == ENEMY_ACTION_ADDSTATE){
					enemyState(ccnt) += int(enemyActionValue(ccnt, cond_num, cnt))
				}else{
					break
				}
			loop
		}
	loop

	//enemy move
	repeat enemyCount
		if(enemyIsAlive(cnt)){
			pos cnt * 100, 200
			mes "[move]"
			cond_num = judgeCondition(cnt, enemyMoveTypeCondition, enemyMoveTypeConditionValue)
			mes "result:" + cond_num
			// pos cnt * 100, 0
			// mes enemyMoveType(cnt, cond_num)
			if(cond_num == -1) : continue
			ccnt = cnt
			repeat ENEMYACTIONSAMETIME_COUNT_MAX
				if(enemyMoveType(ccnt, cond_num, cnt) == ENEMY_MOVE_PROCEED){
					if(enemyDirection(ccnt) == ENEMY_LEFT){
						enemyXV(ccnt) = -enemyMoveValue(ccnt, cond_num, cnt)
					}else : if(enemyDirection(ccnt) == ENEMY_RIGHT){
						enemyXV(ccnt) = enemyMoveValue(ccnt, cond_num, cnt)
					}
					enemyYV(ccnt) += grabityA
				}else : if(enemyMoveType(ccnt, cond_num, cnt) == ENEMY_DONT_MOVE){
					enemyYV(ccnt) += grabityA
				}else{
					break
				}
				pos enemyX(ccnt) - cameraX, enemyY(ccnt) - cameraY + 30
				mes enemyXV(ccnt)
				mes enemyYV(ccnt)
			loop

			tmp = 0
			collide enemyX(cnt), enemyY(cnt), enemyXV(cnt), enemyYV(cnt), tmp, enemyWidth(cnt), enemyHeight(cnt), "enemy"

			//add enemy speed to position
			enemyX(cnt) += enemyXV(cnt)
			enemyY(cnt) += enemyYV(cnt)
		}
	loop

	return